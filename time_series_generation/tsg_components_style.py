import logging
from typing import Any
import numpy as np

"""
This module contains the classes to generate time series using a component approach.
The time series is generated by adding components to a baseline such as trend, seasonality, noise, inactivity, autoregression, and constraints.

"""

# Configure the logger
logging.basicConfig(
    level=logging.INFO,  # Set the logging level
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',  # Format for log messages
    datefmt='%Y-%m-%d %H:%M:%S'  # Format for timestamps
)
logger: logging.Logger   = logging.getLogger("Tsg Components Logger")

class ComponentsFlags:
    """ 
    Class to store the flags for the components of the time series. 
    The flags are used to enable or disable the components of the time series during generation.
    """
    def __init__(self, trend : bool, seasonal : bool, noise : bool, inactivity : bool, autoregression : bool, interval_constraint : bool, sum_constraint : bool):
        self.trend: bool   = trend
        self.seasonal: bool = seasonal
        self.noise: bool = noise
        self.inactivity: bool = inactivity
        self.autoregression: bool = autoregression
        self.interval_constraint: bool = interval_constraint
        self.sum_constraint: bool = sum_constraint

class SeasonalityAttributes:
    """
    Class to store the attributes of the seasonality component of the time series.
    The attributes include the seasonality frequency, the number of parameters, and the coefficients (the An and Bn of the fourier sum ) of the seasonality component.
    """
    def __init__(self, seasonality_frequency : int, paramaters_number : int, coefficients : list[tuple[float, float]]):
        self.seasonality_frequency: int = seasonality_frequency
        self.parameters_number: int = paramaters_number

        if len(coefficients) != paramaters_number:
            raise ValueError("The number of coefficients does not match the number of parameters")
        self.coefficients: list[tuple[float, float]] = coefficients

class TimeSeriesComponents:
    """
    Class to generate the components of the time series using the builder pattern.
    The components include the baseline, trend, seasonality, noise, inactivity, autoregression, and constraints.
    This approach is similar to how Prophet fit the time series
    """
    def __init__(self):
        self.ts = None
        self.components: dict[Any, Any] = {}


    def build_baseline(self, num_units : int, baseline_value : float):
        """Build the baseline component of the time series

        Args:
            num_units (int): The length of the time series
            baseline_value (float): The baseline value of the time series

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """
        # Baseline creation
        self.ts = np.full(num_units, baseline_value, dtype=float)


        self.components["baseline"] = self.ts.copy()
        return self

    def build_trend(self, trend_intervals : list[tuple[int, int]], trend_changes : list[float], m_base : float):
        """Build the piecewise linear trend component of the time series in the same way as defined by Prophet (See paper for details)


        Args:
            trend_intervals (list[tuple[int, int]]): The list of tuples with the start and end indices of each fixed trend period
            trend_changes (list[float]): The list of the changes in the trend for each fixed trend period
            m_base (float): The initial value of the offset in the trend component

        Raises:
            ValueError: If the time series baseline has not been built
            ValueError: If the trend size does not match the time series length

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """

        # Check if baseline has been built
        if self.ts is None:
            raise ValueError('Time series baseline has not been built')

        ts_length : int = self.ts.size
        trend = np.zeros(ts_length)

        # Build the trend iteratively for each trend period (defined by the trend_intervals list)
        cumulate_k_change = 0
        current_m = m_base
        for i,trend_interval in enumerate(trend_intervals):
            min_a, min_b = trend_interval[0], trend_interval[1]
            t = np.arange(1, min_b - min_a + 1)
            trend_p = np.zeros(ts_length)

            # Polynomial trend
            cumulate_k_change += trend_changes[i]
            trend_piece = cumulate_k_change * t + current_m

            # Make the function continuous
            current_m = trend_piece[-1]

            trend_p[min_a:min_b] = trend_piece
            trend = trend + trend_p

        if trend.size != ts_length:
            raise ValueError('Trend size does not match')
        
        # Add the trend to the time series
        self.ts = self.ts + trend
        self.components['trend'] = trend
        return self

    def build_seasonality(self, seasonality_attributes_list : list[SeasonalityAttributes]):
        """Build the seasonality component of the time series using the Fourier sum in the same way as defined by Prophet (See paper for details)

        Args:
            seasonality_attributes_list (list[SeasonalityAttributes]): The list of SeasonalityAttributes objects with the attributes of the seasonality component

        Raises:
            ValueError: If the time series baseline has not been built

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """

        # Check if baseline has been built
        if self.ts is None:
            raise ValueError('Time series baseline has not been built')


        ts_length = self.ts.size
        self.components["seasonality"] = {}
        for seasonality_attributes in seasonality_attributes_list:

            freq = seasonality_attributes.seasonality_frequency
            parameters_number = seasonality_attributes.parameters_number
            coefficients = seasonality_attributes.coefficients
            t = np.arange(ts_length)

            fourier_sum = np.sum(
                [coefficients[n][0] * np.cos((2 * np.pi * (n + 1) * t) / freq) + coefficients[n][1] * np.sin((2 * np.pi * (n + 1) * t) / freq)
                 for n in range(parameters_number)], axis=0
            )

            # Add the seasonality to the time series
            self.components["seasonality"][freq] =  fourier_sum[:freq]
            self.ts = self.ts + fourier_sum
        return self

    def build_noise(self, noise_std : float):
        """Build the noise component of the time series by adding Gaussian noise with mean 0 to the time series

        Args:
            noise_std (float): The standard deviation of the noise

        Raises:
            ValueError: If the time series baseline has not been built

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """

        # Check if baseline has been built
        if self.ts is None:
            raise ValueError('Time series baseline has not been built')

        # Noise
        noise = np.random.normal(0, noise_std, self.ts.size)
        self.components['noise'] = noise
        self.ts = self.ts + noise
        return self

    def build_inactivity(self, inactivity_prob : float):
        """Build the inactivity component of the time series by setting randomly to zero the values of some time steps

        Args:
            inactivity_prob (float): The probability of setting the energy to zero

        Raises:
            ValueError: If the time series baseline has not been built

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """

        # Check if baseline has been built
        if self.ts is None:
            raise ValueError('Time series baseline has not been built')

        # Simulate inactivity (set energy to zero randomly)
        for i in range(self.ts.size):
            if np.random.rand() < inactivity_prob:
                self.ts[i] = 0
        return self

    def build_autoregression(self, number_of_lags : int, coefficients : list[float]):
        """Build the autoregressive component of the time series by adding to each time step the scalar product of the past number of lags of the time series with the coefficients 

        Args:
            number_of_lags (int): The autoregressive order to consider for the autoregressive component
            coefficients (list[float]): The list of coefficients for the autoregressive component

        Raises:
            ValueError: If the time series baseline has not been built
            ValueError: If the number of coefficients does not match the number of lags

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """

        # Check if baseline has been built
        if self.ts is None:
            raise ValueError('Time series baseline has not been built')

        # Check if the number of coefficients matches the number of lags
        if number_of_lags != len(coefficients):
            raise ValueError("The number of coefficients does not match with the number of lags")

        coefficients_np_array = np.array(coefficients)

        autoregressive_component = [0] * number_of_lags

        for i in range(number_of_lags, self.ts.size):
            autoregressive_component.append(np.dot(self.ts[i - number_of_lags : i], coefficients_np_array))

        self.components['autoregression'] = autoregressive_component
        self.ts = self.ts + autoregressive_component
        return self

    def build_min_max(self, max_value : float, normalization_value : float, percentage=0.3):
        """Scale the time series to the specified range [0, max_value] and normalize the time series by subtracting the mean and adding normalization_value

        Args:
            max_value (float): The maximum value of the time series
            normalization_value (float): The value such that the time series has a mean equal to normalization_value plus or minus a percentage
            percentage (float, optional): The value such that the time series has a mean equal to normalization_value plus or minus a percentage. Defaults to 0.3.

        Raises:
            ValueError: If the time series baseline has not been built

        Returns:
            TimeSeriesComponents: The instance of the TimeSeriesComponents class
        """

        if self.ts is None:
            raise ValueError('Time series baseline has not been built')

        # First min-max scaling
        old_min = self.ts.min()
        old_max = self.ts.max()
        self.ts = (self.ts - old_min) * (max_value - 0) / (old_max - old_min)

        # Normalization by subtracting the mean and adding normalization_value
        min_mean = max(0, normalization_value * (1 - percentage))
        max_mean = min(normalization_value * (1 + percentage), max_value)
        normalization = np.random.uniform(min_mean, max_mean)

        mean = self.ts.mean()
        self.ts = self.ts - mean + normalization

        # Iteratively reduce the standard deviation (up to maximum the 20% of the initial value) to avoid outliers and mean normalize the time series to normalization
        current_std = self.ts.std()
        current_ratio_std = 1
        final_ts = self.ts
        while current_ratio_std > 0.2 and (final_ts.min() < 0 or final_ts.max() > max_value):
            final_ts = self.ts * (current_std * current_ratio_std/current_std)
            final_ts = final_ts - final_ts.mean() + normalization
            current_ratio_std -= 0.1
        self.ts = final_ts


        # Truncate the values to the specified range [0, max_value]
        self.ts = np.clip(self.ts, 0, max_value)

        return self

    def build_sum(self, sum_value):
        '''' Constraint the sum of the time series to be sum_value by truncating to 0 the series from the time step where the sum is reached'''

        if self.ts is None:
            raise ValueError('Time series baseline has not been built')

        # Step 1: Compute the cumulative sum
        cumulative_sum = np.cumsum(self.ts)

        # Step 2: Find the index where cumulative sum exceeds the limit
        truncation_index = np.argmax(cumulative_sum > sum_value) if np.any(cumulative_sum > sum_value) else -1

        # Step 3: Truncate the series
        if truncation_index != -1:  # Only truncate if the limit is surpassed
            self.ts[truncation_index:] = 0

        return self

    def get_series(self):
        """Return the time series

        Returns:
            np.ndarray: The time series built with the components
        """
        return self.ts

    def get_components(self) -> dict:
        """Return the dictonary of the components of the time series
        Each component is accessible using as key the name of the component : (baseline, trend, seasonality, noise, autoregression)
        For the seasonality component, there is a further key which is the frequency of the seasonality you want to access

        Returns:
            dict: The dictionary of the components of the time series. 
        """
        return self.components

    def reset(self):
        """Reset the time series components to None
        """
        self.ts = None
        self.components = {}
        return self

class TimeSeriesGeneratorComponents:
    """
    Class representing a random generator that generate time series using the component approach.
    The generator uses the builder pattern to generate the time series with the components specified by the flags and generating randomly the parameters using the configurations passed as input.
    """
    def __init__(self, config: dict):
        self.time_series_components = TimeSeriesComponents()
        self.config = config

    def _baseline_parameters_generation(self) -> tuple[int, float, float, float]:
        """Generate the parameters for the baseline component using the configurations

        Returns:
            tuple[int, float, float, float]: A tuple with the number of units, the baseline value, the max value, and the sum value of the baseline component
        """
        
        baseline_config = self.config["baseline"]
        num_units = np.random.choice(np.arange(baseline_config["n_units_min"], baseline_config["n_units_max"] + 1))

        # If the unit is energy, the baseline value is the energy consumption of the unit in a day else the baseline value is the number of consumption hours in a day
        if baseline_config["unit_is_energy"]:
            baseline_value = np.random.uniform(baseline_config["baseline_min"], baseline_config["baseline_max"])
            daily_hours = np.random.uniform(0, 24)
            max_value = (baseline_value / daily_hours) * 24
            sum_value = baseline_value * num_units
        else:
            baseline_value = np.random.uniform(0, 24)
            max_value = 24
            sum_value = baseline_value * num_units
        logger.info("Baseline")
        logger.info(f"Baseline : Units -> {num_units}, Baseline Value -> {baseline_value}, Max Value -> {max_value}, Sum Value -> {sum_value}")
        return num_units, baseline_value, max_value, sum_value

    def _trend_parameters_generation(self, num_units : int, baseline_value : float) -> tuple[list[tuple[int, int]], list[float], float]:
        """Generate the parameters for the trend component using the configuration file

        Args:
            num_units (int): The length of the time series
            baseline_value (float): The baseline value of the time series

        Returns:
            tuple[list[tuple[int, int]], list[float], float]: A tuple with the list of tuples with the start and end indices of each fixed trend period, the list of the changes in the trend for each fixed trend period, and the initial value of the offset in the trend component
        """

        trend_config = self.config["trend"]

        num_shifts = np.sum(np.random.choice(np.arange(1,trend_config["max_shift_year"] + 1), num_units // 365) )
        change_points = np.random.choice(np.arange(1, num_units), num_shifts, replace=False)
        change_points = np.sort(change_points)
        change_points = np.concatenate(([0], change_points, [num_units]))
        trend_intervals = [(int(change_points[i]), int(change_points[i + 1])) for i in range(change_points.size - 1)]
        m_base = 0


        trend_changes = []
        logger.info("\n\n TREND")
        logger.info(f"Trend : Number of shifts ->{num_shifts}")


        current_rate = 0
        for i, trend_interval in enumerate(trend_intervals):
            # Generate the value change of the time series in the interval and generate accordingly the rate change needed for that value change
            value_change = np.random.uniform(- trend_config["value_change_ratio"], trend_config["value_change_ratio"]) * baseline_value
            interval_rate = value_change / (trend_interval[1] - trend_interval[0])
            trend_change = interval_rate - current_rate
            current_rate = interval_rate
            if i == 0:
                logger.info(
                    f"Trend : Base k Rate -> {interval_rate}, Base m -> {m_base}, Value change -> {value_change}")
            else:
                logger.info(
                    f"Trend : Interval -> {trend_interval}, Rate change -> {trend_change}, Value change -> {value_change}")
            trend_changes.append(trend_change)
        return trend_intervals, trend_changes, m_base

    def _seasonal_parameters_generation(self, baseline_value : float) -> list[SeasonalityAttributes]:
        """Generate the parameters for the seasonality component using the configuration file

        Args:
            baseline_value (float): The baseline value of the time series

        Returns:
            list[SeasonalityAttributes]: A list of SeasonalityAttributes objects with the attributes of the seasonality component
        """
        seasonal_config = self.config["seasonal"]
        seasonality_attributes_list = []
        frequencies = seasonal_config["frequencies"]
        logger.info("\n\n SEASONALITY")


        for seasonality_frequency in frequencies:
            if np.random.choice([True, False], p=[seasonality_frequency["prob"],1 - seasonality_frequency["prob"]]):
                frequency = seasonality_frequency["value"]
                parameters_number = seasonality_frequency["params_number"]
                coefficients = []
                # Generate the coefficients of the fourier sum
                for i in range(parameters_number):
                    a = np.random.normal(0, seasonality_frequency["coeff_ratio_std"] * baseline_value)
                    b = np.random.normal(0, seasonality_frequency["coeff_ratio_std"] * baseline_value)
                    coefficients.append((a, b))
                logger.info(
                    f"Seasonality : Frequency -> {frequency}, N -> {parameters_number} , Coefficients -> {coefficients}")
                seasonality_attributes_list.append(SeasonalityAttributes(frequency, parameters_number, coefficients))
        return seasonality_attributes_list

    def _noise_parameters_generation(self, baseline_value : float) -> float:
        """Generate the parameters for the noise component using the configuration file

        Args:
            baseline_value (float): The baseline value of the time series

        Returns:
            float: The standard deviation of the noise component for the time series
        """
        noise_config = self.config["noise"]
        noise_std = np.random.uniform(0, noise_config["std_max"]) * baseline_value
        logger.info("\n\n NOISE")
        logger.info(f"Noise : Standard Deviation -> {noise_std}")
        return noise_std

    def _inactivity_parameters_generation(self)-> float:
        """Generate the parameters for the inactivity component using the configuration file

        Returns:
            float:  The probability of the inactivity component for the time series
        """
        inactivity_config = self.config["inactivity"]
        inactivity_prob = np.random.uniform(0, inactivity_config["max_prob"])
        logger.info("\n\n INACTIVITY")
        logger.info(f"Inactivity : Probability -> {inactivity_prob}")
        return inactivity_prob

    def _autoregression_parameters_generation(self) -> tuple[int, list[float]]:
        """Generate the parameters for the autoregression component using the configuration file

        Returns:
            tuple[int, list[float]]: A tuple with the number of lags and the list of coefficients for the autoregression component
        """
        autoregressive_config = self.config["autoregression"]
        number_of_lags = np.random.randint(0, autoregressive_config["max_number_of_lags"] + 1 )
        coefficients = []
        for i in range(number_of_lags):
            coefficients.append(np.random.normal(0, autoregressive_config["max_coefficient"]))
        logger.info("\n\n AUTOREGRESSION")
        logger.info(f"Autoregression : Number of lags -> {number_of_lags}, Coefficients -> {coefficients}")
        return number_of_lags, coefficients

    def generate(self, ts_flags: ComponentsFlags, baseline=None)-> list[float]:
        """Generate the time series using the component approach with the components specified by the flags and the parameters generated randomly using the configurations

        Args:
            ts_flags (ComponentsFlags): The flags that specify which components to include in the time series
            baseline (dict, optional): The baseline configuration in case there is already a base configuration for the baseline component and no parameters need to be generated. Defaults to None.

        Returns:
            list[float]: The time series generated with the components
        """
        self.time_series_components.reset()

        # Build the baseline
        if baseline is None:
            num_units, baseline_value, max_value, sum_value = self._baseline_parameters_generation()
        else:
            num_units = baseline["num_units"]
            baseline_value = baseline["baseline_value"]
            max_value = baseline["max_value"]
            sum_value = baseline["sum_value"]


        self.time_series_components.build_baseline(num_units, baseline_value)

        # Build the trend
        if ts_flags.trend:
            self.time_series_components.build_trend(*self._trend_parameters_generation(num_units, baseline_value))

        # Build the seasonality
        if ts_flags.seasonal:
            self.time_series_components.build_seasonality(self._seasonal_parameters_generation(baseline_value))

        # Build the noise
        if ts_flags.noise:
            self.time_series_components.build_noise(self._noise_parameters_generation(baseline_value))

        # Build the autoregression component
        if ts_flags.autoregression:
            self.time_series_components.build_autoregression(*self._autoregression_parameters_generation())

        # Add the scale of min and max
        if ts_flags.interval_constraint:
            self.time_series_components.build_min_max(max_value, baseline_value)

        # Add inactivities
        if ts_flags.inactivity:
            self.time_series_components.build_inactivity(self._inactivity_parameters_generation())

        # Add the constraints of the sum
        if ts_flags.sum_constraint:
            self.time_series_components.build_sum(sum_value)

        return self.time_series_components.get_series().tolist()


